\def\thudbabelopt{english,italian}

\documentclass[target=bach,aauheader=,style=]{thud}

\course{Internet of Things, Big Data, Machine Learning}

\title{Sviluppo di un sistema per il monitoraggio di sensori per atleti}
\author{Alessandro Gaspari}
\supervisor{Prof. Ivan Scagnetto}
\cosupervisor{Dott.ssa Giulia Bongiorno \\ Dott. Luca Miceli}
\tutor{Ivan Scagnetto}



\usepackage[a-1b]{pdfx}
\usepackage[pdfa]{hyperref}
\usepackage{graphicx}
\usepackage{geometry}
\usepackage{subcaption}
\usepackage{listings}
\usepackage{xcolor}

\lstdefinelanguage{dart}{
  keywords={
    abstract, else, import, show, as, enum, in, static,
    assert, export, interface, super, async, extends, is,
    switch, await, extension, late, mixin, this,
    break, external, new, throw, case, factory, null, true,
    false, catch, final, on, try, class, finally, operator,
    typedef, const, for, part, var, continue, get, set,
    rethrow, void, default, if, return, while, Stream, StreamController, StreamSubscription, Future, Widget, StatelessWidget, StatefulWidget, BuildContext,
    State, Key, required, override, super, MaterialApp, Scaffold, Container, Column, Row, Text, ListView, Expanded, Center, Padding, SizedBox, GestureDetector, Navigator, ThemeData, isEmpty
  },
  keywordstyle=\bfseries,
  sensitive=true,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  morestring=[b]",
}

\begin{document}
\maketitle

\begin{dedication}
    Dedica da scrivere

\end{dedication}

\acknowledgements
Ringraziamenti da scrivere.


%% Indice
\tableofcontents

%% Lista delle tabelle (se presenti)
%\listoftables

\listoffigures

%% Corpo principale del documento
\mainmatter

%% Parte
%% La suddivisione in parti è opzionale; solitamente sono sufficienti i capitoli.
%\part{Parte}

%% Capitolo
\chapter{Introduzione}

%% Sezione
\section{Ambito}
Negli ultimi anni, la raccolta dati tramite sensori IMU\footnote{Per IMU (Inertial Measurement Unit) si intendono sensori (accelerometri, giroscopi e magnetometri) che integrano internamente tre dispositivi di acquisizione attivi sugli assi $x$, $y$, $z$.} indossati da atleti ha subito una trasformazione significativa grazie all’evoluzione tecnologica dei microcontrollori e dei protocolli di comunicazione wireless, rendendo la misurazione dei parametri biomeccanici\footnote{I parametri biomeccanici sono delle misure usate per analizzare ed ottimizzare il movimento e la postura dell'atleta.} sempre più precisa, efficiente e integrabile in applicazioni di sensoristica avanzata. Questo progresso ha reso possibile una comprensione più approfondita dei movimenti corporei, aprendo la strada a sistemi di monitoraggio sofisticati che possono supportare allenatori, fisioterapisti e atleti nel miglioramento delle performance e nella prevenzione degli infortuni.

Questo progetto si colloca nell'ambito del monitoraggio sensoristico applicato al mondo dello sport, con particolare attenzione sia al tracciamento in tempo reale che all’analisi in differita dei dati raccolti. L'obiettivo è studiare in dettaglio i movimenti degli arti inferiori dell’atleta, analizzando in modo approfondito:

\begin{itemize}
    \item Movimenti sugli assi $x$, $y$, $z$ del ginocchio, per valutare flessibilità articolare e prevenire infortuni.
    \item Movimenti sugli assi $x$, $y$, $z$ della tibia, per analizzare l’efficienza della falcata\footnote{Per falcata si intende il movimento di una gamba tra un appoggio al terreno e il successivo.} e la distribuzione delle forze.  
    \item Pressioni plantari laterali, frontali e posteriori, utili per identificare squilibri posturali e ottimizzare la tecnica dell’atleta.
\end{itemize}
Gli sport presi come riferimento sono il pattinaggio e la corsa, attività caratterizzate da movimenti complessi e intensi, che permettono la raccolta di numerosi dati in tempi relativamente brevi. L’analisi dei dati raccolti consente di ottenere metriche precise e affidabili, confrontabili tra atleti o sessioni differenti, fornendo così una base solida per valutazioni tecniche e studi comparativi tra varie attività dello stesso atleta o tra atleti con diversi livelli di abilità.
\section{Obiettivi}
Gli obiettivi principali del progetto sono:

\begin{enumerate}
    \item L'implementazione di un'applicazione mobile user-friendly\footnote{Con il termine user-friendly si intende un'interfaccia facile da utilizzare e intuitiva.} che consenta la profilazione dell'atleta, la connessione dei sensori e l'avvio (con il conseguente arresto) del tracciamento delle attività, con particolare attenzione alla facilità d’uso anche per utenti non esperti.
    \item Lo sviluppo di un sistema di memorizzazione sicuro e remoto, che garantisca la registrazione completa dei dati raccolti dai sensori, evitando la perdita di informazioni o conflitti tra dispositivi.
    \item La creazione di una dashboard\footnote{Con l'espressione dashboard si indica un'interfaccia grafica che mostra i dati in modo chiaro.} web reattiva che consenta la visualizzazione dei dati in tempo reale durante l’attività, o in differita tramite funzionalità di replay, rendendo immediata la comprensione delle performance e la possibilità di effettuare confronti tra diverse sessioni.
\end{enumerate}
Questi obiettivi non solo mirano a garantire il corretto funzionamento tecnico del sistema, ma anche a fornire strumenti utili per l’analisi avanzata delle performance, con una particolare attenzione all’usabilità e alla fruibilità dei dati.
\section{Risultati}
I risultati ottenuti confermano la validità delle scelte progettuali. L'applicazione mobile sviluppata è intuitiva e minimalista, permettendo all’atleta di concentrarsi sull’attività senza distrazioni. Il sistema di memorizzazione remoto assicura la registrazione completa e sicura dei dati, eliminando errori come lo scambio di nomi tra sensori o la perdita di informazioni. La dashboard web offre una rappresentazione chiara e fluida dei dati, consentendo agli utenti di monitorare performance e progressi in tempo reale, oppure di rivedere le sessioni passate per analisi dettagliate.
\section{Sinossi}
Questa tesi ha lo scopo di illustrare in dettaglio ogni fase dello sviluppo del sistema di monitoraggio proposto. Nei capitoli successivi, verrà esposto il problema principale affrontato con un confronto tra le soluzioni attualmente disponibili sul mercato, per poi proseguire con i requisiti tecnici e funzionali necessari allo sviluppo e le scelte progettuali implementate. Successivamente saranno inoltre trattati gli aspetti legati all’integrazione dei sensori, all’architettura dell’applicazione mobile e della dashboard web, con porzioni di codice opportunamente commentate, per comprendere al meglio le scelte progettuali attuate, verranno inseriti screenshot per mostrare i diversi casi d’uso. Infine, si presenteranno i risultati ottenuti, le possibili limitazioni e le opportunità di miglioramento e ottimizzazione del sistema per futuri sviluppi.
\chapter{Il problema}
\section{Esposizione del problema}
Nel contesto dell'attività sportiva moderna, l'analisi dei movimenti degli atleti risulta ormai indispensabile per correggere e migliorare notevolmente le abilità dell'agonista o dell'amatore. La raccolta dati tramite dispositivi di sensoristica sempre più avanzati, evidenzia quanto sia effettivamente critico il monitoraggio per evitare infortuni e per migliorare le performance.

\begin{figure}[htbp]
\centering
\begin{tabular}{cc}
\includegraphics[width=0.48\textwidth]{assets/PercentualeAdozione.png} &
\includegraphics[width=0.48\textwidth]{assets/GraficoMaratone.png} \\
(a) Adozione di sensori fra atleti & (b) Tempi mediani di arrivo nelle maratone
\end{tabular}
\caption{Confronto fra adozione di sensori wearable e performance nelle maratone.}
\label{fig:tabular}
\end{figure}
Come possiamo osservare a sinistra della figura \ref{fig:tabular}, all'inizio del 2010, gli sportivi, agonisti e non, che utilizzavano nei loro allenamenti dei sensori indossabili erano una piccolissima porzione rispetto al totale degli atleti. Infatti si parla di solamente un 2\%, secondo una stima basata su un'analisi di mercato dei fitness tracker in Nord America \cite{fortune2025wearables} e un'altra analisi di mercato in tutto il mondo \cite{grandview2024}.
Cinque anni dopo, nel 2015, si è osservato un incremento significativo nell'adozione dei sensori wearable, secondo anche un utile sondaggio effettuato fra gli allenatori americani \cite{luczak2020coaches}. Nel 2020 avvenne l'incremento più sostanzioso, portando più della metà degli atleti a utilizzare sensori durante i loro allenamenti per migliorare le prestazioni ed evitare infortuni dovuti a scorretti movimenti o appoggi. Ad oggi si stima che circa l'85\% di tutti gli atleti mondiali utilizzino sensori wearable per il monitoraggio avanzato durante le loro attività.

Proseguendo con l'analisi del secondo grafico, generato utilizzando i dati del World Athletics Database \cite{camminady2023wa}\footnote{Il World Athletics Database è una collezione di dati presente su GitHub con numerosi risultati di varie discipline sportive riguardanti l'atletica} possiamo invece notare come negli anni, sempre partendo dal 2010 e arrivando ad oggi, i tempi mediani con cui i maratoneti portavano a termine la loro corsa sono diminuiti considerevolmente, partendo da circa 129 minuti, arrivando a 127 negli ultimi anni, delineando un trend decrescente, che ci indica dunque come gli atleti riescano a mantenere una velocità più alta durante tutta la maratona, permettendogli di ottenere delle performance ottimali\footnote{Il picco negativo registrato nel 2020, è dovuto all'annullamento della maggior parte delle gare a causa del Covid-19, permettendo solo a professionisti di altissimo livello, la partecipazione ad una scarsa quantità di eventi}. L'analisi della maratona risulta migliore per comprendere al meglio quanto sia effettivamente efficace l'utilizzo dei sensori wearable durante gli allenamenti rispetto all'analisi di una corsa più breve, poiché in un tratto di pista maggiore, l'atleta dovrà sforzarsi per più tempo a mantenere una postura corretta, un appoggio del piede costantemente equilibrato e un movimento delle articolazioni coordinato, gli permetterà dunque di accumulare vantaggio data la lunga durata della gara. Questo miglioramento di performance risulterebbe minimo se non nullo in una gara così breve come i cento metri ad esempio, la cui ridotta lunghezza non consentirebbe all'atleta di accumulare vantaggio correggendo costantemente i suoi errori. L'altro vantaggio molto importante da considerare è sicuramente quello della prevenzione infortuni. In molti sport si osserva che, per sovraccarichi muscolari o appoggi squilibrati, si vanno a generare delle lesioni talvolta anche molto gravi negli atleti, costretti poi a dover intraprendere un percorso di riabilitazione. Secondo uno studio \cite{barca_innovationhub_2025} tenuto dal centro medico sportivo del famoso club calcistico Barcellona però, l'integrazione di dati biometrici e fisici raccolti attraverso sensori wearable, riescono ad anticipare e predire segnali di rischio infortunio, evitando così che l'atleta possa farsi del male, compromettendo la sua salute.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{assets/InfortuniBarcellona.png}
    \caption{Infortuni stagionali del Barcellona FC pre e post adozione di sensori}
    \label{Infortuni_Barcellona} 
\end{figure}
Questo viene anche confermato dal grafico in figura \ref{Infortuni_Barcellona}, costruito basandosi sul dataset di Transfermarkt \cite{transfermarkt2023injuries}. Analizzando il grafico, notiamo come nel 2021, nel Barcellona si fosse registrato il maggior numero di infortuni per stagione. A seguito dell'adozione di sensoristica moderna e allenamenti mirati alla prevenzione di infortuni, come citato dal Barça Innovation Hub \cite{barca2021wearables}, il numero di infortuni diminuì notevolmente, rendendo profittevole l'investimento sulla sensoristica. Un altro importante studio
tenuto da Preatoni Ezio \cite{preatoni2022wearables} evidenzia come le tecnologie sensoristiche indossabili (e.g. accelerometri o giroscopi) riescano a registrare dei dati che consentano la successiva identificazione di alterazioni di movimento o di carichi di lavoro, associati al rischio di infortunio. 

Un importante studio specifico sul pattinaggio corsa\footnote{Il pattinaggio corsa è una specialità del pattinaggio a rotelle regolamentata a livello internazionale, praticata su piste indoor/outdoor o su strada.} ha analizzato l'efficacia di calze intelligenti dotate di sensori
piezoelettrici integrati direttamente nelle fibre tessili (posizionati su metatarso mediale, laterale e
tallone) e accelerometri per il monitoraggio in tempo reale del pattinaggio di velocità. Questi sensori
piezoelettrici rilevano le variazioni di pressione plantare, permettendo di distinguere i pattern motori
tra atleti esperti e neofiti in base a come il complesso piede/pattino veniva appoggiato a terra. Un
parametro aggiuntivo ma importante della ricerca trattata in tale articolo è la misura, mediante i due
accelerometri posizionati a livello dei malleoli esterni, del Bongiorno Index, un indicatore di
efficienza che calcola la percentuale di accelerazione latero-laterale rispetto all'accelerazione globale
impressa durante ogni falcata. Tale indice, già proposto in un precedente lavoro \cite{articlebongiorno1}, veniva in passato
ricavato mediante gli accelerometri di uno smartphone posizionato a livello di S1\footnote{Per S1 si intende la prima vertebra sacrale in regione lombosacrale.}, ma il livello di
precisione raggiunto era inferiore, dipendendo dalla qualità del device/smartphone utilizzato e
potendo risentire di spostamenti del dispositivo stesso durante la pattinata. I risultati dello studio del
2025 mostrano che un atleta d'élite raggiunge un indice significativamente più alto (circa 58\%)
rispetto a un principiante (circa 27\%), definendo una "firma digitale" per l'ottimizzazione tecnica
dell'allenamento \cite{articlebongiorno2}.
Per poter però eseguire le attività di monitoraggio e analisi dei dati registrati dai sensori, si necessita di un sistema efficace e reattivo, facilmente utilizzabile dall'atleta. I sistemi generalmente richiesti per questi tipi di monitoraggi, necessitano di:

\begin{itemize}
   \item Un'applicazione installata sul dispositivo mobile mantenuto dall'atleta durante l'attività per abilitare la connessione ai sensori e l'avvio delle registrazioni.
   \item Una dashboard web che proceda all'elaborazione dei numerosi dati ricevuti, per permettere al soggetto analizzante di controllare tutti i parametri di interesse, in aggiunta alla posizione GPS del dispositivo mantenuto dall'atleta.
\end{itemize}

\section{Stato dell'arte}
\label{statoarte}
Attualmente sul mercato si trovano diversi tipi di applicazioni mobili che permettono il monitoraggio tramite sensoristica avanzata. Una delle più importanti da citare è sicuramente \textit{Sensoria Run} e \textit{Sensoria Lab}. Tramite queste due applicazioni scaricabili dai vari app store, ci si può connettere ai dispositivi Sensoria per effettuare l'abbinamento ad essi e successivamente avviare il tracciamento. Sensoria attualmente offre una vasta gamma di sensori compatibili con l'app, quali:

\begin{itemize}
    \item Calzini con IMU e sensori di pressione laterale, posteriore e frontale (a sinistra nell'immagine \ref{SensoriSensoria}).
    \item Magliette e canottiere con supporto per cardio-frequenzimetri (in mezzo alla figura \ref{SensoriSensoria}).
    \item Cardio-frequenzimetri con precisioni elevate.
    \item Smart Band da polso per misurazioni di parametri biometrici.
    \item Sensori con IMU per gambe o braccia con annessi supporti per l'uso (a destra nell'immagine \ref{SensoriSensoria}).
\end{itemize}

\begin{figure}[h]
    \centering
    \includegraphics[width=1\textwidth]{assets/sensoriasensori.png}
    \caption{Vari dispositivi indossabili del marchio Sensoria.}
    \label{SensoriSensoria}
\end{figure}
Una volta connessi i dispositivi desiderati e avviata l'attività desiderata che si è scelta tra le tante, verranno visualizzati sullo schermo vari dati utili all'atleta, osservabili anche dopo aver terminato l'attività. Difatti nell'app Sensoria Run vi è una schermata di archivio (a sinistra della figura \ref{SchermateSensoria}) tramite la quale è possibile riguardare ciascuna attività osservando grafici statici sulle performance dell'atleta durante il monitoraggio, in aggiunta a delle statistiche calcolate in media su tutto il percorso. Dalla dashboard web di Sensoria invece si può osservare il percorso effettuato su una mini mappa, con informazioni aggiuntive sul percorso, come dati sull'appoggio del piede, oppure informazioni su miglioramenti o peggioramenti nel tempo impiegato per compiere un determinato percorso già registrato in precedenza.

\begin{figure}[htbp]
\centering
\begin{tabular}{cc}
\includegraphics[width=0.18\textwidth]{assets/sensoriaRun.png} &
\includegraphics[width=0.48\textwidth]{assets/WebSensoria.png} \\
(a) Schermata di riepilogo attività in app & (b) Schermata web di riepilogo attività 
\end{tabular}
\caption{Schermate di dashboard web e app per il riepilogo attività.}
\label{SchermateSensoria}
\end{figure}
Tutte queste informazioni consultabili rendono il monitoraggio utile, dando la possibilità di correggere eventuali carichi troppo alti sulle articolazioni o appoggi squilibrati semplicemente osservando i grafici e le statistiche. Un ulteriore dato molto importante, anche per la sicurezza dell'atleta, è il monitoraggio del battito cardiaco; infatti, osservando le variazioni di esso, è possibile accorgersi di eventuali anomalie (come battito troppo elevato o troppo basso) che potrebbero indicare problemi cardiaci nell'atleta.  
Tramite l'altra applicazione ideata dagli sviluppatori di Sensoria, ossia Sensoria Lab, pensata principalmente per chi si occuperà dell'analisi approfondita dei dati (ricercatori, sviluppatori...), si potranno analizzare tutti i dati raw\footnote{I dati raw (o dati grezzi) sono l'insieme delle informazioni acquisite dai sensori non sottoposte ad alcun processo di filtraggio per la normalizzazione, mostrando il dato così come viene registrato.} ricevuti dai vari sensori, verificandone il corretto funzionamento e rendendo possibile un'analisi ancora più approfondita dei dati. Per poter però utilizzare Sensoria Lab, l'applicazione richiede l'acquisto dell'Software Development Kit\footnote{L'SDK è un pacchetto di strumenti per sviluppatori e ricercatori che utilizza le librerie ufficiali del produttore per integrare e raccogliere dati.} alla cifra di 999\$ l'anno per utente.

Un altro importante prodotto sul mercato delle applicazioni per sensori, è sicuramente \textit{Coospo Ride}. Questa app, incentrata sull'analisi della velocità dell'atleta e del suo battito cardiaco, permette di collegarsi ai dispositivo Coospo per poter poi procedere al monitoraggio. In questo caso i sensori sono meno complessi di quelli marchiati Sensoria, trattandosi prevalentemente di cardio-frequenzimetri talvolta combinati a sensori GPS per il tracciamento delle varie statistiche derivate dalla velocità.

\begin{figure}[htbp]
\centering
\begin{tabular}{cc}
\includegraphics[width=0.22\textwidth]{assets/coospohw.png} &
\includegraphics[width=0.22\textwidth]{assets/coospobici.png} \\
(a) Fascia da polso Coospo HW807 & (b) Ciclocomputer Coospo BC107
\end{tabular}
\caption{Vari sensori per atleti del marchio Coospo.}
\label{SensoriCoospo}
\end{figure}
Tramite l'app si potranno collegare i dispositivi desiderati e, come su Sensoria Run (vista nella sezione \ref{statoarte}), una volta avviata l'attività si potranno osservare a schermo diverse informazioni diverse in base al tipo di dispositivo che stiamo usando. Nel caso di utilizzo di un fascia da polso Coospo, per esempio, nell'app potremo vedere il nostro attuale battito cardiaco, seguito dalla velocità a cui stiamo correndo o camminando, in aggiunta ad ulteriori informazioni sull'attività che stiamo svolgendo. In questo modo si potrà denotare come durante l'attività dell'atleta ci saranno diverse "zone" che racchiuderanno un range di battiti. In base alla zona in cui ci troveremo in un dato momento del nostro allenamento, corrisponderà una percentuale di sforzo a cui si dovrà arrivare per ottimizzare la performance sportiva. In alcuni sensori come nell'HW807 (a sinistra della figura \ref{SensoriCoospo}) sarà visibile anche sul sensore stesso la zona tramite la colorazione di un led. Esistono anche altri tipi di sensori più complessi, come il ciclocomputer presente a destra della figura \ref{SensoriCoospo}, dal quale si potranno ottenere molte più informazioni osservandolo rispetto ad una fascia da polso. Una volta registrate e salvate correttamente le attività sarà possibile consultarle unicamente in app, potendo scorrere e analizzare diverse informazioni utili come si vede nell'immagine \ref{schermateCoospo}.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.85\textwidth]{assets/schermataCoospo.png}
    \caption{Schermate di riepilogo attività dell'app Coospo Ride.}
    \label{schermateCoospo}
\end{figure}
Tra queste informazioni si può trovare:

\begin{itemize}
    \item La distanza percorsa.
    \item La velocità media su tutto il percorso.
    \item Il battito medio.
    \item Le calorie bruciate.
    \item Quanto tempo siamo restati in ogni "zona" di bpm.
    \item Numerosi grafici illustranti le varie misurazioni.
    \item Una mappa per visualizzare graficamente il percorso.
\end{itemize}

\section{Sviluppo ad-hoc}
Considerate le soluzioni analizzate nello stato dell'arte, è emersa la necessità di ideare un sistema ad-hoc per implementare delle funzionalità assenti nelle applicazioni ad oggi esistenti. Una di queste è la possibilità di poter osservare in modo più generico la mappa di un determinato percorso compiuto, colorando la mappa in base al battito registrato in un determinato settore, per dare un feedback immediato all'analizzatore delle diverse zone componenti il tracciato. Se si parla inoltre di proporre una soluzione strettamente professionale e non amatoriale, la scelta ottimale sarebbe esentare l'atleta da qualsiasi compito se non quello di avviare il tracciamento via app, scindendo dunque le funzionalità dell'app mobile, strettamente correlate all'avvio e all'arresto dell'attività, da quelle della dashboard web riservata all'addetto del monitoraggio, che comprenderanno l'analisi e la pulizia dei dati, creando statistiche utili e mostrando completamente ogni tipo di dato disponibile (compresi i dati raw). Un ulteriore aspetto negativo nei prodotti presentati è la complessità dell'interfaccia in app, che porta l'atleta, non sempre esperto nell'ambito tecnologico, a confondersi e di conseguenza non riuscire nell'intento di collegare i sensori per avviare il monitoraggio dell'attività. Nella soluzione proposta e illustrata in questa tesi, l'interfaccia rimane minimale e intuitiva per permettere all'utente di capire istantaneamente come utilizzare l'applicativo, evitando di mantenere numerose e caotiche schermate che renderebbero caotico tutto il sistema. In entrambe le applicazioni proposte prima, la connessione ai sensori era strettamente riservata ai dispositivi dello stesso marchio dell'app, escludendo quindi di poter utilizzare, cardio-frequenzimetri di una marca e sensori di un'altra. Nella soluzione proposta invece, sono supportati tutti i tipi di dispositivi del marchio Sensoria per i dati più complessi, in aggiunta a qualsiasi tipo di dispositivo per il rilevamento del battito cardiaco, sfruttando la lettura delle caratteristiche Bluetooth di ogni unità collegata allo smartphone via app. Un'importante funzionalità non presente nella maggioranza dei prodotti presenti sul mercato, è la possibilità di trattare le attività registrate come replay, potendo scorrere tramite una comoda barra, lungo tutta la durata dell'attività, percependo meglio ogni singola variazione di dati nei sensori e permettendo così un'analisi molto più approfondita e precisa.

\subsection{Analisi dei requisiti}
I requisiti del sistema sono stati suddivisi in funzionali e non, al fine di garantire un'utilizzo piacevole mantenendo il corretto funzionamento dei componenti software. I requisiti funzionali comprenderanno:

\begin{itemize}
    \item Creazione di un profilo utente con annessi dati personali.
    \item Connessione a sensori IMU e calzini sensorizzati Sensoria.
    \item Connessione a cardio-frequenzimetri.
    \item Avvio e arresto del monitoraggio via app.
    \item Memorizzazione remota sicura.
    \item Visualizzazione dei dati raw via dashboard web.
    \item Visualizzazione di angoli di piegamento vari e pressioni plantari.
    \item Visualizzazione dei Bongiorno Indexes per ogni tibia.
    \item Visualizzazione della posizione GPS dell'atleta.
    \item Visualizzazione di statistiche legate allo spostamento.
    \item Replay delle attività.
\end{itemize}
Passando invece ai requisiti non funzionali, il sistema dovrà essere:

\begin{itemize}
    \item Affidabile.
    \item Estremamente reattivo.
    \item Piacevolmente usabile.
    \item Sicuro per i dati.
    \item Scalabile.
    \item Intuitivo.
\end{itemize}
Il complesso di tutti questi requisiti rappresenta un tassello fondamentale per la corretta riuscita del progetto, garantendone un'elevata efficienza e proponendo un'alternativa solida alle soluzione disponibili attualmente sul mercato, implementando nuove funzionalità innovative.

\subsection{Casi di studio}
Qui elencati si possono trovare alcuni casi di studio che coprono quasi tutte le possibilità di utilizzo del sistema:
\begin{enumerate}
    \item Atleta durante l'allenamento: l'atleta si prepara per il monitoraggio accendendo tutti i sensori e verificandone il corretto funzionamento tramite la colorazione di un led. Più precisamente i sensori che utilizza comprendono un sensore IMU posto sopra al ginocchio, un sensore IMU posto sotto al ginocchio, un cardio-frequenzimetro a fascia o a pettorina, e due calzini sensorizzati. Prosegue dunque, indossando uno ad uno tutti i sensori tramite le apposite fasce o sostegni. Successivamente, avvia l'applicazione, seleziona il suo profilo precedentemente creato e si connette a tutti i sensori accesi, verificando l'avvenuto abbinamento tramite il cambio di colore del led. Nel caso in cui un determinato sensore sia invertito (per esempio un sensore solitamente indossato a sinistra viene indossato a destra) gli basta modificare il nome del sensore, ovviando alla scomodità di doverselo togliere e rimettere. Una volta accesi, indossati e connessi i sensori, l'atleta procede a premere il tasto per l'avvio del tracking e aspetta cinque secondi a gambe dritte e parallele per la corretta calibrazione. Terminata la calibrazione procede con la vera e propria attività, potendo  comodamente mantenere il telefono a schermo spento. Una volta conclusa l'attività, l'atleta riaccende lo schermo del telefono per premere il tasto di fine tracciamento. In questo modo la registrazione dei dati avviene in modo corretto, terminando così il compito dell'atleta.
    \item Allenatore in analisi post-attività: una volta terminata l'attività, l'allenatore si connette alla dashboard web per consultare tramite il menù l'attività che gli interessa, facilmente distinguibile dalla data in cui essa è stata registrata. Una volta scelta e scaricata l'attività tramite l'apposito tasto, l'allenatore osserva a sinistra della dashboard gli spostamenti dell'atleta tramite una mappa interattiva, arricchita da informazioni quali velocità, distanza e battito cardiaco in quel preciso istante. Tramite una barra scorrevole posta in fondo alla mappa può spostarsi lungo tutta la durata dell'attività a suo piacimento per analizzare meglio determinate zone. A destra della mappa interattiva, può invece osservare, in un determinato istante le pressioni plantari dell'atleta, i Bongiorno Indexes, gli angoli di inclinazione delle tibie e l'angolo di flessione del ginocchio. Dalla mappa inoltre, l'allenatore può subito comprendere meglio le zone di sforzo maggiore dell'atleta semplicemente osservando il colore dei vari tratti del percorso. Tratte le conclusioni a seguito della revisione dei dati, l'allenatore indica all'atleta le zone più critiche e gli errori effettuati più comuni, per riuscire a migliorare le sue performance e prevenire eventuali infortuni.
    \item Ricercatore in analisi dati raw: il ricercatore si connette alla dashboard e carica un'attività, potendo così osservare in fondo al sito tutti i dati non filtrati dei sensori connessi durante l'attività. Essi comprendono tutti i dati dei sensori IMU (accelerometro, giroscopio e magnetometro) su tutti gli assi (x, y e z). Nel caso dei sensori montati sulle tibie, si vedono anche le pressioni laterali e frontali dei calzini. Osservando questi dati, il ricercatore può controllare se alcuni sensori restituiscono outliers\footnote{Con il termine outliers ci si riferisce a dei valori anomali rispetto a quelli precedentemente osservati.} oppure se certi valori tendono a rimanere fissi anche durante il movimento (segno di potenziale malfunzionamento del sensore). Una volta osservati tutti i valori, il ricercatore, se ha la possibilità di accedere al codice sorgente, può modificare determinati indici a suo piacimento o crearne di nuovi in base alle sue esigenze.
\end{enumerate}

\subsection{Modello di sviluppo}
Per lo sviluppo del sistema proposto è stato utilizzato un modello di sviluppo iterativo agile\footnote{Il modello di sviluppo iterativo agile prevede dei brevi cicli di sviluppo, chiamati sprint, abbinati ad un continuo confronto con l'utente.}, garantendo così alta flessibilità, elevata aderenza alle esigenze e uno sviluppo più rapido. L'adozione di questo modello di sviluppo si è rilevata particolarmente adatta al contesto del progetto siccome i requisiti erano in continua evoluzione in relazione alle richieste dell'utente. Il continuo confronto con gli utilizzatori finali ha assicurato che l'usabilità e l'efficienza fossero costantemente in crescita, grazie a costanti feedback e test. Questi ultimi hanno anche prevenuto errori progettuali che avrebbero causato ulteriori problematiche durante lo sviluppo del sistema. Ogni nuova funzionalità importante, una volta terminata, veniva prontamente testata per verificarne il corretto funzionamento ed eventualmente correggerne i bug presenti, assicurando così di ottenere un prodotto funzionante e facilmente perfezionabile grazie all'indipendenza di ogni componente dalle altre. Un altro importante fattore che ha contribuito alla riuscita di questo progetto è stata la possibilità di testare sul campo le funzionalità implementate di tanto in tanto, garantendo così un feedback più reale e veritiero.

\subsection{Architettura della soluzione}
L'architettura della soluzione proposta è di tipo modulare, progettata per acquisire, salvare, elaborare e visualizzare numerose quantità di dati provenienti da sensori wearable. Il sistema è composto da più livelli, ciascuno responsabile di determinate funzionalità al fine di garantire scalabilità, usabilità e flessibilità. 
Per garantire ordine, solidità ed efficacia, lo schema secondo il quale la soluzione è stata proposta segue la figura \ref{flowchart}\footnote{Lo schema composto dalla linea intera indica l'architettura pensata per il monitoraggio live. L'alternativa a linea tratteggiata mostra invece l'architettura del monitoraggio post attività.}.

\begin{figure}[h]
    \centering
    \includegraphics[width=1\textwidth]{assets/FLOWCHART.png}
    \caption{Diagramma di flusso dell'architettura proposta.}
    \label{flowchart}
\end{figure}
Come si può notare, la prima fase del flusso è banalmente l'accensione e il montaggio dei sensori, comprendenti al massimo un cardio-frequenzimetro due sensori IMU per il ginocchio e due calzini sensorizzati. Una volta accesi essi possono essere successivamente connessi tramite l'applicazione apposita, avviando conseguentemente il monitoraggio. Nella fase successiva avviene dunque la calibrazione, che consiste nel mantenimento di una posizione a gambe tese e parallele per cinque secondi, al fine di ottenere gli angoli corretti di piegamenti delle tibie e flessioni del ginocchio. In seguito alla calibrazione avverrà l'acquisizione dei dati dell'attività praticata dall'atleta. Dall'istante in cui l'atleta avvierà l'attività, tutti i dati relativi ad essa saranno visibili online in tempo reale grazie alla dashboard. Una volta terminato il monitoraggio tramite app, il log relativo all'attività verrà salvato su un server remoto, tramite il quale si potrà poi visualizzare con la funzionalità di replay tutti i dati delle attività passate. Con questo intuitivo flusso di funzionamento, si giunge quindi ad una soluzione minimale che permette di analizzare i dati in modi diversi a seconda delle necessità, mantenendo sempre un rendimento elevato e puntando alla semplicità d'uso per l'utente.

\subsection{Caratteristiche tecniche}
\label{caratteristichetecniche}
Il sistema proposto è composto da un'applicazione mobile disponibile per dispositivi iOS o android, e una dashboard web accessibile da qualsiasi browser. Per la gestione e la memorizzazione dei dati invece è stato utilizzato un backend remoto. Il framework\footnote{Un framework è un insieme di strumenti e librerie che fornisce una struttura di base per sviluppare applicazioni o software.} utilizzato per lo sviluppo dell’applicazione è stato \textit{Flutter}, ideato da Google.
Esso permette tramite un unico codice di creare app su iOS, Android, Web e Desktop in maniera affidabile e ottimizzata. Questo è reso possibile da una caratteristica unica, ossia il suo motore grafico
“Skia” che elabora ogni componente da zero, al contrario, per esempio, di React\footnote{React è una libreria di JavaScript sviluppata da Facebook per costruire interfacce dinamiche e reattive.} che utilizza dei componenti nativi. 
In questo modo l’UI\footnote{Con il termine UI (User Interface) si indica l'insieme degli elementi grafici, visivi e interattivi attraverso i quali un utente interagisce con un sistema.} sarà identica per tutti i dispositivi, indipendente dal sistema operativo installato su di essi, e facilmente
personalizzabile a seconda delle esigenze dell'utente.
Tra le altre comodità di Flutter troviamo sicuramente il fatto di poter sviluppare una schermata alla volta, con una percezione della reattività elevata grazie ad una funzionalità che prende il nome di "Hot Reload", tramite la quale non occorrerà chiudere ogni volta l’applicazione dopo una modifica per poi riaprirla ricompilando tutto il
codice, ma semplicemente basterà eseguire una scorciatoia da tastiera per rigenerare velocemente la schermata interessata (in qualche decimo di secondo)
apportando le modifiche effettuate. Inoltre, tutti i componenti in Flutter sono dei StatelessWidget
(statici) o dei StatefulWidget (dinamici in base ai dati ricevuti).
Il linguaggio su cui si basa Flutter si chiama \textit{Dart}. Anch’esso possiede numerosi vantaggi, tra cui:

\begin{itemize}
    \item La compilazione in codice nativo, che prevede la trasformazione di un programma scritto in un linguaggio di alto livello in istruzioni direttamente eseguibili dal processore del dispositivo, ottimizzando così il programma essendo che verràe eseguito direttamente dalla CPU.
    \item Un garbage collector efficiente per evitare di sprecare sezioni di memoria inutilizzate.
    \item Una gestione degli streaming ottimizzata. 
\end{itemize}
Riprendendo l'ultimo punto, fondamentale in questo progetto, il flusso che segue uno streaming di dati su Dart, è il seguente:

\begin{enumerate}
    \item Dart ottiene un valore.
    \item Il valore viene messo in una coda
    \item L'UI di Flutter lo riceve (in pochi millesimi di secondo)
    \item La schermata si aggiorna mostrando il dato
\end{enumerate}
Tramite questo algoritmo di funzionamento, anche streaming ad alta frequenza sono facilmente supportati, garantendo così una gestione di grandi quantità di dati.
Ciò è anche dovuto alla gestione del WebSocket\footnote{Con l'espressione WebSocket ci si riferisce ad un protocollo di comunicazione che permette uno scambio bidirezionale di informazioni tramite una connessione persistente}, difatti quando esso verrà avviato, l’app creerà un canale di comunicazione sempre attivo in modo da facilitare lo scambio di informazioni in tempo
reale tra le varie parti. 
Dart, per velocizzare l’esecuzione, ha due modalità di compilazione:

\begin{enumerate}
    \item Ahead Of Time, solitamente utilizzata quando bisogna pubblicare l’app sullo store ufficiale, utilizzando
    codice macchina nativo e assicurando stabilità.
    \item Just In Time, usata durante lo sviluppo e composta da un codice che rimane molto flessibile per aggiornamenti frequenti a discapito di un'instabilità maggiore.
\end{enumerate}
Per ottimizzare ulteriormente la gestione dei dati provenienti dai sensori, Flutter sfrutta gli \textit{Isolates} di Dart, che consentono di processare i pacchetti ricevuti in background senza bloccare l'interfaccia utente, utilizzando un sistema di buffering\footnote{Con il termine buffering ci si riferisce ad un processo di caricamento anticipato di dati in un'area di memoria.} per evitare sovraccarichi di memoria.
Tutte queste funzionalità permettono all’applicazione di operare correttamente su molteplici piattaforme evitando ritardi, latenze o interruzioni brusche salvaguardando la reattività e favorendo l’utilizzo piacevole ed intuitivo da parte dell’utente. La comunicazione tra i sensori e l'applicazione mobile avviene tramite Bluetooth Low Energy (BLE), scelto per il suo basso consumo energetico e per l'elevata affidabilità nello streaming di dati. Grazie ad esso tutti i dati relativi ad accelerazioni, rotazioni, variazioni del campo magnetico e pressioni provenienti dai sensori vengono acquisiti in tempo reale dall'app. Il BLE risulta quindi fondamentale, essendo che il protocollo per la trasmissione deve essere robusto ed efficace, capace di supportare scambi di grandi quantità di dati. In questo caso particolare infatti, i sensori wearable utilizzati per l'analisi dei movimenti degli arti inferiori (del marchio Sensoria) trasmettono ognuno ad una frequenza di 100 Hertz, inviando così un pacchetto di dati raw ogni dieci millisecondi. Per quanto riguarda la frequenza di trasmissione del cardio-frequenzimetro e del geolocalizzatore integrato al telefono, esse equivalgono a un Hertz ma sono identiche per due motivi diversi. Il cardio-frequenzimetro trasmette a questa determinata frequenza per il fatto che più di un dato al secondo riguardante il battito cardiaco risulterebbe inutile, mentre il GPS dello smartphone è limitato a trasmettere al massimo a un Hertz, per limitare notevolmente il consumo della batteria del dispositivo evitando così di scaricarsi troppo in fretta.

Attualmente l'applicazione mobile, testata su dispositivi iOS, necessita di essere installata tramite uno store alternativo e non tramite App Store ufficiale Apple. Questo è dovuto al fatto che Apple richiede un pagamento annuale di 100\$ per poter pubblicare sullo store anche una singola applicazione. Con l'ausilio di iLoader, un programma disponibile al download su qualsiasi dispositivo con sistema operativo MacOS, si può procedere all'installazione dello store alternativo (in questo caso SideStore) direttamente sul dispositivo con iOS, precedentemente impostato in modalità di sviluppo dalle impostazioni di sistema dello smartphone. Al completamento dell'installazione sarà possibile aprire lo store alternativo sul dispositivo e aggiungere il proprio file \textit{.ipa} che consentirà l'installazione dell'applicazione di monitoraggio, in modo da poterla poi utilizzare. Una limitazione perturbante relativa all'utilizzo di uno store alternativo e non ufficiale è sicuramente l'obbligo di dover rinnovare entro ogni settimana i certificati di autenticità dell'applicativo installato per evitare di dover rieseguire tutto l'intero processo di installazione dello store da Mac. 

Per quanto riguarda la memorizzazione dei dati acquisiti durante i monitoraggi, il sistema si affida ad un server fisico remoto dedicato, accessibile tramite connessione sicura. Tramite un programma in linguaggio Python, il server si metterà in ascolto su una determinata porta, e, ogni qual volta che l'applicazione mobile riceverà dei dati dai sensori, li inoltrerà alla porta aperta del server, che li gestirà al fine di memorizzarli uno per uno senza perdite di dati e con un timestamp preciso per le analisi in tempo reale, o in differita, della dashboard web. Per poter accedere al server si necessita di un nome utente registrato ed una password, assicurando così l'avvio di programmi interni al server o modifiche di file presenti in esso solo da parte degli amministratori. Una volta che verrà terminato il monitoraggio dall'app si procederà ad arrestare anche il programma Python sul server, procedendo così in maniera automatizzata al salvataggio con nome univoco del log contenente tutti i dati. I sensori IMU montati sopra e sotto il ginocchio salveranno per ogni pacchetto:

\begin{itemize}
    \item Accelerazione sugli assi $x$, $y$ e $z$ (nei log compariranno come accx, accy, accz).
    \item Dati del giroscopio sugli assi $x$, $y$ e $z$ (nei log compariranno come gyrx, gyry, gyrz).
    \item Variazioni del campo magnetico sugli assi $x$, $y$ e $z$ (nei log compariranno come magx, magy, magz).
\end{itemize}
Inoltre, per poter riconoscere quale utente effettua un'attività, viene salvato sul server anche un dato "USER PROFILE" che come valore avrà proprio il nome del profilo attivo nel momento dell'avvio del monitoraggio.

Alla luce di quanto esposto, si passa ora all'analisi delle caratteristiche tecniche riguardanti la dashboard web. Essa è composta da molteplici file con linguaggi diversi, i principali sono:

\begin{itemize}
    \item Un file Python che permette la corretta gestione della logica applicativa, coordinando le comunicazioni fra applicazione e server, gestendo le richieste fra le due parti, elaborando i dati ricevuti e fornendoli quando vengono richiesti dalla dashboard.
    \item Un file HTML\footnote{Con l'acronimo HTML (HyperText Markup Language) si indica un linguaggio usato per strutturare i contenuti delle pagine web.} per la creazione della struttura del sito, in modo tale da assicurare ad ogni sezione di essere visibile e reattiva in base ai dati ricevuti.
    \item Un file CSS\footnote{CSS (Cascading Style Sheets) è un linguaggio di stile usato per definire gli aspetti dei vari contenuti presenti in un HTML.} per la visualizzazione animata e user-friendly del sito, assicurando così una piacevole esperienza all'utente, mantenendo dei colori che non vadano a distrarre troppo ma che allo stesso tempo siano informativi su ciò che vogliono indicare.
    \item Un file JavaScript, cuore pulsante della dashboard, che sarà responsabile dell'interfaccia utente, elaborando i dati ricevuti dal backend\footnote{Il backend è la sezione di un software o sito web, che gestisce la logica, l'archiviazione dati e le richieste.} utilizzandoli per aggiornare i contenuti visualizzati. Un'importante funzionalità che troviamo implementata al suo interno, testimoniante l'importanza di questo file, è la modalità di replay attività. 
\end{itemize}
Uno dei file più importanti e pesanti è stato scritto in JavaScript, un linguaggio di programmazione dinamico che esegue direttamente nel browser, riducendo il carico sul server, assicurando reattività e permettendo di osservare vari cambiamenti su una pagina web senza il bisogno di doverla aggiornare ogni singola volta. Un vantaggio molto importante di questo linguaggio, è la sua perfetta integrazione con HTML e CSS, ma soprattutto il supporto della programmazione asincrona, che rende efficiente la gestione delle operazioni non bloccanti\footnote{Le operazioni non bloccanti sono operazioni che non fermano l'esecuzione del programma, permettendo così di eseguire contemporaneamente altre istruzioni.} 

Durante la programmazione di tutte le varie componenti del sito, è stato utilizzato come repositorio GitHub, piattaforma online che permette di ospitare, gestire e condividere progetti utilizzando Git (un sistema di controllo). Grazie ad esso, quando un utente modificherà del codice in locale sulla sua macchina, poi potrà, con un semplice comando, salvarlo online in modo che chiunque debba lavorare su quel determinato progetto abbia tutti gli aggiornamenti necessari. Più nello specifico, quando si desidererà salvare i propri cambiamenti ad un codice nel repositorio online si effettuerà il comando \textit{git push} sul proprio terminale dell'IDE\footnote{Con il termine IDE si indica un ambiente di sviluppo software che integra in un programma tutti gli strumenti necessari per programmare.}. Se invece un utente vorrà ottenere i nuovi aggiornamenti del codice, gli basterà digitare il comando \textit{git pull}, ovviamente preceduto da una fase di configurazione del repositorio online. GitHub è stato utilizzato in questo progetto anche per permettere ad una piattaforma di deployment l'esecuzione di tutto il codice presente nel repositorio. In questo caso particolare, la soluzione adottata è stata \textit{Render.com}, un sito web che per l'appunto si occupa di fare hosting e gestire il deployment in modo automatizzato. Più precisamente non appena verrà eseguito un push dal codice su GitHub, Render eseguirà l'auto-deploy (come si può notare nell'ultima riga dell'immagine \ref{render}), assicurando così un aggiornamento costante della dashboard web. 

\begin{figure}[h]
    \centering
    \includegraphics[width=1\textwidth]{assets/render.png}
    \caption{Schermata di impostazione parametri su Render.com.}
    \label{render}
\end{figure}
Come si può osservare nella figura \ref{render}, la prima istruzione che verrà seguita ad ogni deploy sarà quella di installare tutti i requisiti necessari per il corretto funzionamento dell'app sul sito. Successivamente verrà avviato il programma Python citato precedentemente, che inizializzerà così tutti i processi al suo interno richiamando gli altri file. Per la corretta operatività del sito risulta fondamentale l'impostazione delle credenziali per accedere al server remoto in fase di lettura dati. Una volta che il deploy avrà avuto successo, si potrà accedere alla pagina contenente la dashboard con tutti i dati aggiornati in tempo reale o in replay, tramite un comodo link condivisibile e accessibile da chiunque. 

\chapter{Implementazione}

\section{Introduzione}
Nel seguente capitolo verranno analizzate nel dettaglio tutte le parti di codice significative per la realizzazione dell'applicazione mobile e della dashboard web, commentando ed esplicando attentamente ogni funzionalità. Partendo da una visione generale del complesso sistemistico si giungerà dunque a degli approfondimenti sulle varie componenti. Verranno mostrati esempi pratici, snapshot di codice e screenshot delle interfacce, al fine di fornire una comprensione chiara del funzionamento del sistema e delle scelte progettuali adottate. L'obiettivo non è solo descrivere come il sistema sia stato implementato, ma anche motivare le scelte tecniche e metodologiche dietro ogni soluzione adottata. 

\section{Sviluppo dell'applicazione mobile}
\subsection{File di configurazione}
Al fine della corretta esecuzione del codice, Flutter necessita di alcuni file di configurazione presenti all'interno della cartella principale contenente il codice dell'applicazione. Uno dei più importanti prende il nome di default \textit{pubspec.yaml}.

\begin{lstlisting}[caption={Alcune delle dipendenze presenti nel file pubspec.yaml.}, label={pubspec}]
dependencies:
  flutter:
    sdk: flutter
  google_fonts: ^6.3.3
  flutter_blue_plus: ^1.32.12
  geolocator: ^13.0.2
  apple_maps_flutter: ^1.4.0
  cupertino_icons: ^1.0.8
\end{lstlisting}

Al suo interno troveremo tutte le dipendenze necessarie a flutter, la versione dell'ambiente di sviluppo, il nome e la descrizione dell'applicazione, insieme anche all'impostazione dell'icona. Tra le varie dipendenze, come possiamo notare nel listato \ref{pubspec} troviamo librerie dedicate a:

\begin{itemize}
    \item Organizzazione delle icone interne all'applicazione.
    \item Gestione del BLE.
    \item Autorizzazione all'acquisizione di dati relativi alla geolocalizzazione.
    \item Inizializzazione dei socket. 
    \item Esecuzione delle funzioni relative all'app in background.
\end{itemize}
Tra gli altri numerosi file di configurazione, molti dei quali poco rilevanti all'analisi, troviamo due ulteriori codici importanti per la corretta esecuzione su Android e iOS. Essi, infatti, sono rispettivamente \textit{AndroidManifest.xml} e \textit{Info.plist}. Al loro interno ci saranno essenzialmente le stesse configurazioni essendo che su entrambi i sistemi operativi si necessiterà di ottenere delle autorizzazioni dal dispositivo per poter far utilizzare l'applicazione. Queste autorizzazioni riguarderanno, similarmente a quanto visto precedentemente nel file \textit{pubspec.yaml}, Bluetooth, geolocalizzazione, esecuzione in background e altri requisiti per l'interfaccia utente.  

\subsection{Schermate}
Flutter organizza il complesso del codice dividendolo in più schermate, ognuna delle quali viene collegata alle altre per far sì che ci si possa spostare comodamente tra di esse. La prima schermata che in questo progetto si visualizzerà una volta aperta l'app per la prima volta sarà la \textit{\textbf{profile screen}}, per far si che l'utente possa creare il suo profilo inserendo i suoi dati.

\begin{figure}[htbp]
\centering
\begin{tabular}{cc}
\includegraphics[width=0.2915\textwidth]{assets/profilovuoto.png} &
\includegraphics[width=0.30\textwidth]{assets/profilopieno.png} \\
(a) Schermata iniziale vuota & (b) Schermata iniziale compilata
\end{tabular}
\caption{Schermate iniziali di profilazione utente.}
\label{schermateiniziali}
\end{figure}

Prima però, per poter effettivamente verificare che in memoria locale non ci siano già dei profili creati, verrà effettuato il controllo \ref{verificaprofili}.
\begin{lstlisting}[language=dart, caption={Istruzione per la verifica dell'esistenza di eventuali profili.}, label={verificaprofili}]
if (profileProvider.profiles.isEmpty) {
  return const ProfileFormScreen();
}
\end{lstlisting}
Una volta verificata l'assenza di profili dunque, apparirà la schermata per la compilazione, al cui interno si troveranno tre campi di input in cui inserire le informazioni richieste dal form, che verranno poi verificate per evitare errori futuri causati da profili con informazioni mancanti.

\begin{lstlisting}[language=dart, caption={Validazione dei campi di input del form.}, label={formvalidation}]
if (_formKey.currentState!.validate()) {
  // salvataggio dati
}
\end{lstlisting}
Al di sotto di essi si troveranno due card colorate dedicate alla scelta del genere, e una lista di avatar tra cui poter scegliere la preferita, assicurando così un'esperienza di personalizzazione minimale ma completa all'utente. A concludere la pagina è presente il pulsante di salvataggio, il quale consente la memorizzazione dei dati inseriti all’interno di una struttura persistente gestita dal provider.

\begin{lstlisting}[language=dart, caption={Creazione o modifica di un profilo utente.}, label={saveprofile}]
if (widget.profileToEdit == null) {
  provider.addProfile(name, age, gender, weight, avatar);
} else {
  provider.updateProfile(id, name, age, gender, weight, avatar);
}
\end{lstlisting}
La schermata di creazione e modifica del profilo è stata progettata come componente riutilizzabile, permettendo di distinguere automaticamente tra inserimento di un nuovo profilo e aggiornamento di uno esistente, riducendo la duplicazione del codice e migliorando la gestione dell’applicazione.

Una volta creato il profilo utente e validato i suoi dati, l'applicazione si spostera autonomamente alla seconda schermata, ossia la \textit{\textbf{scanner screen}}. Essa viene trattata come uno StatefulWidget, (\ref{caratteristichetecniche}) essendo che dovrà gestire dinamicamente tutte le informazioni che riceverà. Al suo interno verranno implementate varie funzionalità quali scansioni Bluetooth, accesso alle schermate successive, stato del GPS e qualità del segnale. 
\begin{figure}[htbp]
\centering
\begin{tabular}{cc}
\includegraphics[width=0.30\textwidth]{assets/screenvuota.jpg} &
\includegraphics[width=0.30\textwidth]{assets/scansione.jpg} \\
(a) \textit{Scanner screen} iniziale. & (b) \textit{Scanner screen} in fase di scansione.
\end{tabular}
\caption{Screenshot delle schermate \textit{scanner screen}.}
\label{scannerscreens}
\end{figure}

\begin{lstlisting}[language=dart, caption={Definizione della schermata di scansione.}, label={scanner_def}]
class ScannerScreen extends StatefulWidget {
  const ScannerScreen({Key? key}) : super(key: key);

  @override
  State<ScannerScreen> createState() => ScannerScreenState();
}
\end{lstlisting}
Nel codice che la compone si trovano numerose variabili di stato indicanti informazioni necessarie all'applicazione per evitare di eseguire operazioni nel caso in cui lo stato non sia quello previsto. Alcune di esse, visionabili nel frammento di codice \ref{scanner_vars}, includono la lista dei dispositivi Sensoria rilevati (a seguito di un previo filtraggio tra tutti i dispositivi Bluetooth), lo stato della scansione, le condizioni del modulo BLE e del GPS, oltre ai dati di un eventuale cardio-frequenzimetro connesso.

\begin{lstlisting}[language=dart, caption={Variabili di stato della schermata.}, label={scanner_vars}]
List<ScanResult> _sensoriaDevices = [];
bool _isScanning = false; 
BluetoothAdapterState _adapterState = BluetoothAdapterState.unknown;
GpsSignalQuality _gpsQuality = GpsSignalQuality.poor; 
bool _isStartingTracking = false; 
BluetoothDevice? _connectedHrm; 
int? _localBpm;
\end{lstlisting}
Per quanto riguarda lo stato del GPS, affinchè la lettura di esso sia immediata, è stata implementata un'enumerazione nominata \textit{GpsSignalQuality} composta da tre valori di qualità segnale a cui verranno assegnati automaticamente icone e testi personalizzati.
Facendo così, al posto di mostrare i dati grezzi dell'accuratezza GPS in metri, i dati verranno categorizzati facilitandone la comprensione.

\begin{lstlisting}[language=dart, caption={Classificazione della qualità GPS in base all'accuratezza.}, label={gps_accuracy}]
if (position.accuracy < 10) {
  _gpsQuality = GpsSignalQuality.excellent;
} else if (position.accuracy < 30) {
  _gpsQuality = GpsSignalQuality.good;
} else {
  _gpsQuality = GpsSignalQuality.poor;
}
\end{lstlisting}
Quando giungerà il momento di effettuare la scansione dei dispositivi Bluetooth nelle vicinanze verrà sfruttato un filtro (mostrato nel listato \ref{ble_filter}) dedicato a scartare tutti i dispositivi al di fuori dei prodotti Sensoria. Esso permette, tramite un controllo della nomenclatura BLE, di mostrare così solo dispositivi compatibili con l'applicazione.

\begin{lstlisting}[language=dart, caption={Ascolto dei risultati BLE e filtraggio dei dispositivi Sensoria.}, label={ble_filter}]
_scanSubscription = FlutterBluePlus.scanResults.listen((results) {
  final scannedSensoria = results.where((result) {
    final name = result.device.advName.toLowerCase();
    return name.contains('sensoria');
  }).toList();
  setState(() => _sensoriaDevices = scannedSensoria);
});
\end{lstlisting}
L'effettiva scansione Bluetooth (una volta verificato che esso sia stato attivato sullo smartphone) verrà gestita invocando il pacchetto di Flutter chiamato \textit{FlutterBluePlus}. Una volta premuto il tasto di scansione, verrà avviata la rilevazione dei dispositivi per un periodo di 10 secondi, al fine di non consumare eccessivamente la batteria del dispositivo.

\begin{lstlisting}[language=dart, caption={Avvio della scansione BLE con verifica dello stato dell'adapter.}, label={ble_scan}]
if (_adapterState != BluetoothAdapterState.on) {
  _showMessage('Attiva il Bluetooth per continuare');
  return;
}
await FlutterBluePlus.startScan(
  timeout: const Duration(seconds: 10),
  androidUsesFineLocation: true,
);
\end{lstlisting}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.30\textwidth]{assets/connessi.jpg}
    \caption{\textit{Scanner screen} post fase di connessione e personalizzazione sensori.}
    \label{connessi}
\end{figure}

Una volta effettuata la scansione, l'utente avrà la possibilità di connettersi al sensore desiderato direttamente dalla \textit{scanner screen} tramite un comodo pulsante. L'alternativa è quella di cliccare sul sensore e passare ad una nuova schermata, la \textit{device detail screen} che verrà analizzata in seguito. Per connettersi al sensore, il sistema verificherà prima se il dispositivo risulta già connesso tramite il \textit{ConnectedDeviceProvider}. In caso positivo, lo disconnetterà, altrimenti procederà a connettersi ad esso, sfruttando un provider dedicato ai singoli dispositivi (come si osserva nello snippet \ref{device_connect}). \\ \\

\begin{lstlisting}[language=dart, caption={Connessione e disconnessione di un sensore dalla lista.}, label={device_connect}]
if (isConnected) {
  await devicesProvider.disconnectDevice(device);
} else {
  await devicesProvider.connectDevice(device);
}
\end{lstlisting}
Connessi tutti i dispositivi Sensoria, si passerà all'eventuale connessione del cardio-frequenzimetro tramite l'apposito tasto in alto a destra nelle figure \ref{scannerscreens} e \ref{connessi}. L'applicazione attualmente supporta una grande quantità di sensori dedicati all'analisi del battito cardiaco, essendo che ricerca nei cardio-frequenzimetri la caratteristica Bluetooth 0x2A37, in molti indicante per l'appunto il valore relativo ai BPM. Una volta connesso al cardio-frequenzimetro, l'app si iscriverà allo stream dei dati RAW che poi verranno processati ed elaborati al fine di essere visualizzati come battiti per minuto, aggiornando la UI e il provider.

\begin{lstlisting}[language=dart, caption={Sottoscrizione alla caratteristica BLE per la lettura del BPM.}, label={hrm_bpm}]
await hrmChar.setNotifyValue(true);
_hrmSubscription = hrmChar.lastValueStream.listen((value) {
  final bpm = _parseHeartRate(value);
  if (bpm != null) setState(() => _localBpm = bpm);
});
\end{lstlisting}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.30\textwidth]{assets/cardiofreq.jpg}
    \caption{Schermata a comparsa dedicata alla connessione di cardio-frequenzimetri}
    \label{cardiofreq}
\end{figure}
Come si può osservare nello screenshot \ref{cardiofreq} con lo stesso principio di funzionamento, si potrà eseguire la scansione per dispositivi in grado di misurare il battito cardiaco. Una volta connesso, la card del dispositivo si colorerà di verde per indicare l'avvenuto abbinamento. Un'ulteriore verifica di connessione sarà la comparsa in alto a destra (al posto del tasto per l'aggiunta del cardio-frequenzimetro) del battito cardiaco rilevato secondo per secondo dal sensore. 

L'ultima informazione presente sulla \textit{scanner screen} si riferisce allo stato del server per la memorizzazione e lo streaming di dati su Render.com. Esso risulterà "off" quando il codice Python citato in \ref{caratteristichetecniche} non sarà attivo, "on" altrimenti. Questo importante controllo viene delegato allo \textit{StreamingManager} (approfondito in seguito) che tramite il widget \textit{Consumer<StreamingManager>} si metterà in ascolto della variabile booleana \textit{isServerReachable}. Ogni volta che verrà rilevata una variazione nella connessione, verrà notificato, permettendo così l'aggiornamento dell'interfaccia tramite una nuova colorazione dell'indicatore e un cambio di testo. 

\begin{lstlisting}[language=dart, caption={Lettura dello stato del server tramite provider.}, label={server_status}]
Consumer<StreamingManager>(
  builder: (context, manager, child) {
    final isReady = manager.isServerReachable;
    return Text(isReady ? "SERVER ON" : "SERVER OFF");
  }
)
\end{lstlisting}

Dopo aver connesso i dispositivi Sensoria, il cardio-frequenzimetro e aver verificato la disponibilità del server si potrà procedere all'avvio del tracciamento tramite l'apposito tasto "avvia tracking". Sempre tramite lo \textit{StreamingManager} verranno aperti tutti i socket dei sensori, trasmettendo in aggiunta anche i dati relativi al profilo utente, in modo da poterlo visualizzare sul sito. 

\begin{lstlisting}[language=dart, caption={Avvio degli stream, invio del profilo e navigazione alla TrackingScreen.}, label={start_tracking}]
await manager.startAllStreaming(
  devicesProvider.connectedDevices, devicesProvider.deviceNames,
);
if (activeProfile != null) {
  await manager.sendProfileData(
    activeProfile.name, activeProfile.age,
    activeProfile.gender, activeProfile.weight,
  );
}
Navigator.push(context,
  MaterialPageRoute(builder: (_) => const TrackingScreen()));
\end{lstlisting}
Per evitare perdite di memoria o mantenimenti inutili di connessioni attive, quando la schermata verrà chiusa, il sistema invocherà il metodo \textit{dispose} che chiuderà tutte le sottoscrizioni alle varie streaming (Bluetooth, GPS...).

Come descritto in precedenza, quando si cliccherà su un determinato dispositivo disponibile tra quelli scansionati, si passerà ad una nuova schermata di personalizzazione ed eventuale connessione. Essa prende il nome di \textit{\textbf{device detail screen}} e, lavorando su un singolo sensore, avrà necessità di ricevere l'istanza del dispositivo Bluetooth, il suo nome e la sua tipologia. Anche questa schermata sfrutterà lo \textit{StreamingManager} per sottoscriversi allo streaming relativo allo stato del dispositivo, in modo da poter aggiornare reattivamente l'indicatore di connessione in caso di cambiamenti. In questa schermata sarà possibile anche personalizzare il sensore a proprio piacimento come più si riterrà utile; come prima cosa verrà perciò interrogato il provider relativo ai dispositivi connessi per sapere se precedentemente l'utente aveva già modificato il nome o l'icona del sensore. Nel caso in cui il sistema riesca a trovare in memoria una personalizzazione per quel determinato sensore (riconosciuto univocamente dal suo ID) essa verrà mostrata. 

\begin{lstlisting}[language=dart, caption={Recupero dell'emoji associata tramite il provider condiviso.}, label={detail_emoji}]
String _getDeviceEmoji() {
  final devicesProvider = Provider.of<ConnectedDevicesProvider>(...);
  final customIconType = devicesProvider.getDeviceIconType(widget.device);
  
  if (customIconType != null && _emojiMap.containsKey(customIconType)) {
    return _emojiMap[customIconType]!;
  }
  return '?';
}
\end{lstlisting}

\begin{figure}[htbp]
\centering
\begin{tabular}{cc}
\includegraphics[width=0.49\textwidth]{assets/custom.jpg} &
\includegraphics[width=0.50\textwidth]{assets/personalizzato.jpg} \\
(a) Schermata di personalizzazione sensore. & (b) Schermata post personalizzazione.
\end{tabular}
\caption{Screenshot delle schermate \textit{device detail screen}.}
\label{detailscreens}
\end{figure}

Terminata la procedura di personalizzazione, i nuovi dati relativi al sensore verranno subito salvati, forzando poi la ricostruzione dell'entità relativa al sensore per sovrascrivere i dati e aggiornare le informazioni a schermo. Quando l'utente si riterrà soddisfatto potrà comodamente tornare alla \textit{scanner screen} semplicemente premendo il tasto apposito posto in alto a sinistra nelle immagini \ref{detailscreens}, il che invocherà un \textit{dispose} che cancellerà le sottoscrizioni in ascolto dello stato di connessione relative al sensore preso in considerazione. 

L'ultima schermata dell'applicazione accessibile prima di effettuare il tracciamento sarà quella dedicata ai profili, precedentemente utilizzata al primo avvio dell'applicazione. Tramite i pulsanti dedicati in essa si potranno modificare i profili esistenti (cliccando sul tasto a forma di matita), eliminare i profili indesiderati (tramite il pulsante a forma di cestino) o aggiungere ulteriori profili tramite il tasto in alto a destra della schermata. L'unica limitazione, gestita autonomamente dal sistema, è quella di mantenerne almeno un profilo attivo per evitare problematiche future. Nella \textit{\textbf{profile screen}} si potranno osservare tutte le informazioni relative ai profili (nome, icona, età, peso e genere) e, cliccando sopra uno di essi lo si potrà impostare come profilo attivo, con il quale verranno registrate tutte le attività che verranno svolte. Questa schermata viene trattata come uno StatelessWidget essendo che non dovrà mantenere mutabilità, basandosi interamente sul \textit{ProfileProvider}. In questo modo ogni volta che si modificherà, aggiungerà o eliminerà un profilo la schermata si ricostruirà automaticamente. 
Per renderizzare l'elenco dei profili si utilizzerà un costrutto ottimizzato di Flutter che creerà i widget solo quando staranno per essere visualizzati a schermo (attuando dunque una procedura di lazy loading). Questo costrutto prende il nome di \textit{ListView.builder} (\ref{profiles_list}) e verificherà inoltre se il profilo interessato sarà attivo o meno, modificando in caso il suo stile, come si può vedere a sinistra della figura \ref{profilescreens}.

\begin{figure}[htbp]
\centering
\begin{tabular}{cc}
\includegraphics[width=0.30\textwidth]{assets/profilivari.jpg} &
\includegraphics[width=0.30\textwidth]{assets/customprofilo.jpg} \\
(a) Scelta dei profili nella \textit{profile screen}. & (b) Schermata di personalizzazione profilo.
\end{tabular}
\caption{Screenshot delle schermate \textit{profile screen}.}
\label{profilescreens}
\end{figure}

\begin{lstlisting}[language=dart, caption={Generazione dinamica della lista contenente i profili salvati.}, label={profiles_list}]
ListView.builder(
  itemCount: provider.profiles.length,
  itemBuilder: (context, index) {
    final profile = provider.profiles[index];
    final isActive = profile.id == provider.activeProfile?.id;
    final isMale = profile.gender == "M";
    
    //Ritorno della UI della singola card
  },
)
\end{lstlisting}

Quando verrà cliccato un determinato profilo, come accennato precedentemente, esso verrà impostato come attivo tramite il provider dedicato. Per la modifica invece verrà istanziata una navigazione verso la \textit{ProfileFormScreen} passando come argomento il profilo con tutti i suoi dati per la pre-compilazione della schermata. Per evitare l'appesantimento del codice, la schermata di creazione profilo e modifica profilo sono le medesime con l'unica differenza compresa nel titolo della schermata.
Tramite il codice di \textit{initState} (presente nel listato \ref{form_init}) verrà valutato se il valore di \textit{widget.profileToEdit} sarà nullo o meno, in base a ciò il sistema deciderà se far apparire la schermata con il titolo di "modifica" o di "creazione".\\


\begin{lstlisting}[language=dart, caption={Pre-compilazione dei campi di testo in caso di modifica.}, label={form_init}]
void initState() {
  super.initState();
  _nameCtrl = TextEditingController(text: widget.profileToEdit?.name ?? "");
  _ageCtrl = TextEditingController(text: widget.profileToEdit?.age.toString() ?? "");
  _weightCtrl = TextEditingController(text: widget.profileToEdit?.weight.toString() ?? "");
  
  if (widget.profileToEdit != null) {
    _gender = widget.profileToEdit!.gender;
    _selectedAvatar = widget.profileToEdit!.avatar;
  }
}
\end{lstlisting}

Una volta che la modifica o creazione del profilo sarà stata salvata tramite l'apposito tasto posto in fondo alla schermata, il sistema invocherà un controllo della validazione per ciascun campo di testo per poi formattare i dati e chiamare i metodi \textit{addProfile} (in caso di creazione) o \textit{updateProfile} (in caso di modifica) riportando poi l'utente nella schermata iniziale.
L'unica schermata rimanente dell'applicazione si chiama \textit{\textbf{tracking screen}} e viene mostrata una volta che l'utente avrà premuto sul tasto "avvia tracking" dopo aver connesso i propri sensori e verificato la disponibilità del server.

\begin{figure}[h]
  \centering
  \includegraphics[width=0.30\textwidth]{assets/trackingscreen.jpeg}
  \caption{Screenshot della schermata \textit{tracking screen}.}
  \label{trackingscreen}
\end{figure}
Al suo interno verranno gestite diverse logiche come si può notare in figura \ref{trackingscreen} comprendenti: 
\begin{itemize}
  \item Un cronometro per indicare all'atleta il tempo trascorso dall'inizio dell'attività.
  \item Un indicatore relativo al numero di sensori connessi.
  \item Una lista con tutti i nomi e le icone dei sensori connessi.
  \item Un indicatore dei battiti per minuto estratti dal cardio-frequenzimetro (se connesso).
  \item Il nome dell'utente attualmente attivo.
  \item Una mini-mappa reattiva agli spostamenti e con un indicatore di segnale GPS integrato.
  \item Un indicatore di disponibilità server (in alto a destra).
  \item Un pulsante per fermare il tracking, seguito da un avviso di conferma per evitare arresti involontari. 
\end{itemize}

Quando verrà creata la \textit{tracking screen}, il metodo \textit{initState} avvierà tutte le operazioni in background, lanciando il cronometro, inizializzando i servizi di localizzazione e configurando il cursore indicante la posizione attuale sulla mappa. 

\begin{lstlisting}[language=dart, caption={Inizializzazione dei sistemi di tracking all'apertura della schermata.}, label={tracking_init}]
void initState() {
  super.initState();
  _startTimer();
  _initHighPrecisionMap();

  _markerAnimController = AnimationController(
    vsync: this, duration: const Duration(seconds: 2),
  )..repeat();
  //Inizializzazione animazione cursore
}
\end{lstlisting}
Affinché il tracciamento del cursore nella mappa in app (e sulla dashboard) sia fluido, il sistema crea un timer che interrogherà il GPS ogni secondo (come si vede nella prima riga dello snippet \ref{tracking_gps_polling}), utilizzando il parametro \textit{LocationAccuracy} impostato su \textit{.bestForNavigation}, il che forzerà iOS (o Android) a fornire il dato sulla posizione più recente e preciso possibile. Una volta che sarà stata ottenuta la coordinata, la mappa si sposterà su tale.

\begin{lstlisting}[language=dart, caption={Richiesta ciclica della posizione GPS ad alta precisione.}, label={tracking_gps_polling}]
Timer.periodic(const Duration(seconds: 1), (timer) async {
  if (!mounted) { timer.cancel(); return; }

  try {
    Position position = await Geolocator.getCurrentPosition(
      desiredAccuracy: LocationAccuracy.bestForNavigation,
    );
    
    if (mounted) {
      _lastKnownPosition = position;
      if (!_hasRealPosition) setState(() => _hasRealPosition = true);
      _mapController?.animateCamera(
        CameraUpdate.newLatLng(//Coordinate attuali),
      );
    }
  } catch (e) {//Gestione errore}
});
\end{lstlisting}
Per la gestione del cronometro relativo alla durata dell'attività, al posto di aggiornare il suo valore ogni secondo con una chiamata a \textit{setState} che implicherebbe ri-renderizzare ogni secondo tutte le componenti presenti nella schermata (facendo crollare le prestazioni), il sistema isola questa feature in uno StatelessWidget di piccole dimensioni, ovviando il problema e preservando la fluidità. Quanto l'indicatore in alto a destra della schermata, indicante il possibile raggiungimento o meno del server, esso leggerà il valore \textit{isServerReachable} che eseguirà dei ping continui per poi colorare l'indicatore in base all'esito.

La visualizzazione riguardante la lista dei sensori connessi è gestita da una mappatura dei dispositivi del provider. In questo modo l'app genererà tante card quante saranno i sensori connessi all'avvio dell'attività, e controllerà se il buffer locale in cui verranno immagazzinati i dati starà effettivamente ricevendo dati da quel dispositivo Bluetooth (riconosciuto dal suo ID unico). In caso affermativo mostrerà un led verde lampeggiante, altrimenti rosso. Anche il cardio-frequenzimetro verrà accodato alla lista dei sensori se disponibile, assegnandoli un'icona personalizzata per distinguerlo dagli altri. Nel caso in cui un determinato sensore non abbia un nome personalizzato o un'icona personalizzata gliene verranno assegnate di default. 

\begin{lstlisting}[language=dart, caption={Generazione delle card relative ai dispositivi BLE connessi.}, label={tracking_sensors}]
...devicesProvider.connectedDevices.entries.map((entry) {
  return _buildDeviceCard( //creazione della card sensore
    devicesProvider.deviceNames[entry.key] ?? "Sensoria Device", 
    entry.key, 
    streamingManager.allSensorData[entry.key] != null, 
    _getDeviceEmoji(entry.value, devicesProvider)
  );
}),
if (streamingManager.hrmDeviceName != null)
  _buildDeviceCard(hrmName, "HRM-SENSOR", true, "\\icona cuore"),
\end{lstlisting}
Terminata la sessione, l'utente premerà il pulsante rosso "stop tracking" posto in fondo alla schermata. Questo evento invocherà \textit{StreamingManager} per fermare la registrazione in primis della sessione (con la funzione \textit{stopTracking}) e successivamente dell'invio dati verso il socket (tramite \textit{stopAll}). Per finire l'applicazione ritornerà sulla schermata iniziale rilasciando tutte le risorse precedentemente in uso dalla \textit{tracking screen}.

\begin{lstlisting}[language=dart, caption={Procedura di arresto degli stream dati e chiusura della sessione.}, label={tracking_stop}]
Future<void> _handleStopTracking() async {
  ...
  streamingManager.stopTracking();
  await streamingManager.stopAll();
  ...
}
\end{lstlisting}


\subsection{Providers}
\subsection{File main}


\section{Sviluppo della dashboard web}
\section{Esempi d'uso}


%% Fine dei capitoli normali, inizio dei capitoli-appendice (opzionali)
\appendix

%\part{Appendici}

\chapter{Titolo della prima appendice}
Sed purus libero, vestibulum ut nibh vitae, mollis ultricies augue. Pellentesque velit libero, tempor sed pulvinar non, fermentum eu leo. Duis posuere eleifend nulla eget sagittis. Nam laoreet accumsan rutrum. Interdum et malesuada fames ac ante ipsum primis in faucibus. Curabitur eget libero quis leo porttitor vehicula eget nec odio. Proin euismod interdum ligula non ultricies. Maecenas sit amet accumsan sapien.

%% Parte conclusiva del documento; tipicamente per riassunto, bibliografia e/o indice analitico.
\backmatter

%% Riassunto (opzionale)
%\summary
%Maecenas tempor elit sed arcu commodo, dapibus sagittis leo egestas. Praesent at ultrices urna. Integer et nibh in augue mollis facilisis sit amet eget magna. Fusce at porttitor sapien. Phasellus imperdiet, felis et molestie vulputate, mauris sapien tincidunt justo, in lacinia velit nisi nec ipsum. Duis elementum pharetra lorem, ut pellentesque nulla congue et. Sed eu venenatis tellus, pharetra cursus felis. Sed et luctus nunc. Aenean commodo, neque a aliquam bibendum, mauris augue fringilla justo, et scelerisque odio mi sit amet diam. Nulla at placerat nibh, nec rutrum urna. Donec ut egestas magna. Aliquam erat volutpat. Phasellus vestibulum justo sed purus mattis, vitae lacinia magna viverra. Nulla rutrum diam dui, vel semper mi mattis ac. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae; Donec id vestibulum lectus, eget tristique est.

%% Bibliografia (praticamente obbligatoria)
\bibliographystyle{plain_\languagename}%% Carica l'omonimo file .bst, dove \languagename è la lingua attiva.
%% Nel caso in cui si usi un file .bib (consigliato)
\bibliography{thud}
%% Nel caso di bibliografia manuale, usare l'environment thebibliography.

%% Per l'indice analitico, usare il pacchetto makeidx (o analogo).

\end{document}
